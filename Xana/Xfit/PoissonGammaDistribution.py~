#! /usr/bin/env python
import numpy as np
from numpy import log
from scipy.special import gamma
import lmfit

def stirling(x):
    return np.sqrt(2*np.pi/x)*(x/np.e)**x

def PoissonGamma(x, **p):
    k = p['k']
    M = p['M']
    return gamma(1.*k+M)/(gamma(1.*M)*gamma(1.*k+1.))*1.*(1.*x/(M*1.+x))**k*(1.*M/(x+M))**M

def PoissonGamma_approx(x, **p):
    k = p['k']
    M = p['M']
    return 1. -.5*log(2*np.pi*(k+M)/(M*(1+k))) + (k+M)*log((k+M)/(x+M)) + k*log(x) - (k+1)*log(1+k)    

def PoissonGamma_indk(x, **p):
    kb = p['kb']
    M = p['M']
    return gamma(1.*x+M)/(gamma(1.*M)*gamma(1.*x+1.))*1.*(1.*kb/(M*1.+kb))**x*(1.*M/(kb+M))**M

def PoissonGamma_indk_approx(x, **p):
    kb = p['kb']
    M = p['M']
    return 1. -.5*log(2*np.pi*(x+M)/(M*(1+x))) + (x+M)*log((x+M)/(kb+M)) + x*log(kb) - (x+1)*log(1+x)    


def fit_pg_(prob, pberr=None, ind_var='kb', logscale=False, pbthres=0, st=10, lb=1, ub=np.inf,
          vary_kb=0, deg=2, method='leastsq'):
    """ Fit the Poisson-Gamma distribution
    by minimizing the residuals"""
    
    s = prob.shape
    nim = s[-1]
    nk = fi

    # define residual functions:
    # independent variable is <k>
    def res_kb(pars, x, data=None, eps=None):
        """2D Residual function to minimize
        """
        v = pars.valuesdict()
        
        resid = np.zeros((x.size,nk))
        
        x = x*v['kbc']
        for i,ik in enumerate(kv):
            if logscale:
                model = np.log10(PoissonGamma(x, k=ik, M=v['M{}'.format(i)]))
            elif not logscale:
                model = PoissonGamma(x, k=ik, M=v['M{}'.format(i)])
            if eps is not None:
                resid[:,i] = np.abs(data[:,i] - model)/np.abs(eps[:,i])
            else:
                resid[:,i] = np.abs(data[:,i] - model)
        if np.sum(~np.isfinite(resid))>0:
#            print('Found inf.')
            for i in range(nk):
                model = PoissonGamma_approx(x, k=ik, M=v['M{}'.format(i)])
                if eps is not None:
                    resid[:,i] = np.abs(np.log(data[:,i]) - model)/np.abs(eps[:,i])
                else:
                    resid[:,i] = np.abs(np.log(data[:,i]) - model)
        return resid.flatten()
    
    # independent variable is k; k_bar is fixed or fit parameter
    def res_k(pars, x, data=None, eps=None):
        """2D Residual function to minimize
        """
        v = pars.valuesdict()

        resid = np.zeros((data.shape[0],x.size))
        for i in range(nim):
            if logscale:
                model = np.log10(PoissonGamma_indk(x, kb=v['kb{}'.format(i)], M=v['M{}'.format(i)]))
            elif not logscale:
                model = PoissonGamma_indk(x, kb=v['kb{}'.format(i)], M=v['M{}'.format(i)])
            if eps is not None:
                resid[i,:] = np.abs(data[i,:] - model)/np.abs(eps[i,:])
            else:
                resid[i,:] = np.abs(data[i,:] - model)
        if np.sum(~np.isfinite(resid))>0:
#            print('Found inf.')
            for i in range(nim):
                model = PoissonGamma_indk_approx(x, kb=v['kb{}'.format(i)], M=v['M{}'.format(i)])
                if eps is not None:
                    resid[i,:] = np.abs(np.log(data[i,:]) - model)/np.abs(np.log(eps[i,:]))
                else:
                    resid[i,:] = np.abs(np.log(data[i,:]) - model)
        return resid.flatten()
    
    # use combination of PoissonGamma functions to fit data
    def res_2pg(pars, x, data=None, eps=None):
        """2D Residual function to minimize
        """
        v = pars.valuesdict()
        for i in range(deg):
            if i == 0:
                model = v['A{}'.format(i)]*PoissonGamma_indk(x, kb=v['kb{}'.format(i)], M=v['M0'])
            else:
                model += v['A{}'.format(i)]*PoissonGamma_indk(x, kb=v['kb{}'.format(i)], M=v['M0'])
        if logscale:
            model = np.log10(model)
        if eps is not None:
            resid = np.abs(data - model)/np.abs(eps)
        else:
            resid = np.abs(data - model)
        return resid


    # initialize fit parameters and call minimizer function
    pars = lmfit.Parameters()
    if ind_var == 'kb':
        for i in range(nk):
            pars.add('M{}'.format(i), value=st, min=lb, max=ub)
            if i>0:
                pars['M{}'.format(i)].expr = 'M0'
        pars.add('kbc', value=1., min=0, max=2, vary=vary_kb)
        res = lmfit.minimize(res_kb, pars, args=(kb,), kws={'data':pb, 'eps':pberr}, method=method,
                             nan_policy='omit')
        
    elif ind_var == 'k':
        for i in range(nim):
            pars.add('M{}'.format(i), value=st, min=lb, max=ub)
            pars.add('kb{}'.format(i), value=kb[i], min=0, max=np.inf, vary=vary_kb)
            if i>0:
                pars['M{}'.format(i)].expr = 'M0'
        res = lmfit.minimize(res_k, pars, args=(kv,), kws={'data':pb, 'eps':pberr}, method=method,
                             nan_policy='omit')
                             
    elif ind_var == 'ks2':
        pars.add('M0', value=st, min=lb, max=ub)
        for i in range(deg):
            pars.add('kb{}'.format(i), value=(np.random.randn()*.2+0.9)*kb, min=0., max=np.inf, vary=vary_kb)
            pars.add('A{}'.format(i), value=1/deg, min=0, max=1, vary=0)
        res = lmfit.minimize(res_2pg, pars, args=(kv,), kws={'data':pb, 'eps':pberr}, method=method,
                             nan_policy='omit') 

    return res

